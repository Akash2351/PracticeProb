
//**********************************************************************************//
11/14/17
Q1) Reverse String:
Write a function that takes a string as input and returns the string reversed.
Example:
Given s = "hello", return "olleh".

    public String reverseString(String s) {
        if (s == null || s.length() == 1)
            return s;

        char[] chars = s.toCharArray();
        StringBuilder sb = new StringBuilder();
        int len = chars.length;

        for (int i = len - 1; i >= 0; i--) {
            sb.append(chars[i]);
        }
        return sb.toString();
    }

//**********************************************************************************//
11/14/17
Q2) Longest Common Prefix
Write a function to find the longest common prefix string amongst an array of strings.

    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0)
            return "";
        if (strs.length == 1)
            return strs[0];

        int maxlen = Integer.MAX_VALUE;
        String min = null;
        //find the length of shortest string..
        // the answer cannot be longer than this.
        for (String str : strs) {
            if (str.length() < maxlen) {
                maxlen = str.length();
                min = str;
            }
        }
        //for 0 to maxlen,
        //check if char[i] is same for all strings,
        //else stop and return till last i;
        boolean end = false;
        for (int i = 0; i < maxlen; i++) {
            for (String str : strs) {
                if (min.charAt(i) != str.charAt(i)) {
                    end = true;
                    break;
                }
            }
            if (end) {
                if (i == 0) return "";
                else
                    return min.substring(0, i);
            }
        }
        return min;
    }

//**********************************************************************************//
11/14/17
Q3)Sum of two integers
Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example:
Given a = 1 and b = 2, return 3.

    public int getSum(int a, int b) {
        if (b == 0)
            return a;
        if (a == 0)
            return b;

        while (b != 0) {
            int carry = a & b;
            a = a ^ b;
            b = carry << 1;
        }

        return a;
    }

//**********************************************************************************//
11/14/17
Q4) Reverse an integer
Input: -123  Output: -321
Example 3: Input: 120 Output: 21

    public int reverse(int x) {
        // when reversing, it can be > int max value,
        //if so, return 0

        long rev = 0;
        while (x != 0) {
            rev = rev * 10 + x % 10;
            x = x / 10;
            //check if val > range, return 0;
            if (rev > Integer.MAX_VALUE || rev < Integer.MIN_VALUE)
                return 0;
        }
        return (int) rev;
    }

//**********************************************************************************//
11/14/17
Q5) Plus one
   inp -> [1,2,4] op-> [1,2,5], ip->[19], op-> [2,0]

    public int[] plusOne(int[] digits) {
        int len = digits.length;
        //traverse from the last digit,
        //if not 9, add one to it and send...
        for (int i = len - 1; i >= 0; i--) {
            if (digits[i] != 9) {
                digits[i] += 1;
                return digits;
            }
            //last digit is 9, make 0, carry over 1.
            // 1 is added by default, no need for carry.
            digits[i] = 0;
        }

        //if we have come here, it means array is all 9's..
        int[] ret = new int[len + 1];
        ret[0] = 1;

        return ret;
    }

//**********************************************************************************//
11/14/17
Q6) Number of 1 Bits

    public int hammingWeight(int n) {
        int count = 0;
        while(n!=0){
            count += (n&1);
            // use >>> for unsigned bit shifting
            // >> for signed bit shifting
            n = n>>>1;
        }
        return count;
    }

//**********************************************************************************//
11/14/17
Q7) Buy Sell stocks 2
Design an algorithm to find the maximum profit. You may complete as many transactions
 as you like (ie, buy one and sell one share of the stock multiple times). However, you may
  not engage in multiple transactions at the same time (ie, you must sell the stock before
   you buy again).
 eg: [2,1,2,0,1] -> 2
   [1,2,4] -> 3

    public int maxProfit(int[] prices) {
        int total = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            if (prices[i + 1] > prices[i]) total += prices[i + 1] - prices[i];
        }
        return total;
    }

//**********************************************************************************//
11/15/17
Q8) Count and Say
 The first term is "1"
 Second term is "11", generated by reading first term as "One 1"
 (There is one 1 in previous term)
 Third term is "21", generated by reading second term as "Two 1"
 -> current value depends on n-1 value.


    public String countAndSay(int n) {
        if(n==1)
            return "1";

        String[] list = new String[n+1];
        list[1] = "1";
        list[2] = "11";

        //generate all combinations till n value..
        for(int i=3; i<=n;i++){
            char[] chars = list[i-1].toCharArray();
            int len = chars.length;
            int j = 0;
            StringBuffer sb = new StringBuffer();
            while(j<len-1){   //coz we are checking til j+1
                int cnt = 1;
                while(j<len-1 && chars[j] == chars[j+1]){j++;cnt++;}
                sb.append(cnt).append(chars[j]);
                j++; //move j to next char..will count in next loop.
                //if its the last character...
                if(j==len-1)
                    sb.append(1).append(chars[j]);
            }
            list[i] = sb.toString();
        }
        return list[n];
    }

//**********************************************************************************//
11/15/17
Q9) happy Number
Example: 19 is a happy number
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

    public static boolean isHappy(int n) {
        if (n == 1)
            return true;

        Set<Integer> set = new HashSet<>();
        int remain = 0;
        //repeat until product is unique..
        while (set.add(n)) {
            int sum = 0;
            while (n > 0) {
                remain = n % 10;
                sum += remain * remain;
                n = n / 10;
            }
            if (sum == 1)
                return true;
            else
                n = sum;
        }
        return false;
    }

//**********************************************************************************//
11/15/17
Q9) Factorial trailers zeros
Given an integer n, return the number of trailing zeroes in n!.

    public static int trailingZeroes(int n) {
        if(n==0)
            return 0;

        int zeros = 0;
        //Because all trailing 0 is from factors 5 * 2.
        //find n/5 + n/25 + n/125 ...
        while(n>0){
            zeros = zeros + n/5;
            n = n/5;
        }
        return zeros;
    }

//**********************************************************************************//
11/15/17
Q10) Odd even list
 Given a singly linked list, group all odd nodes together followed by the even nodes.
 Please note here we are talking about the node number and not the value in the nodes.

    public ListNode oddEvenList(ListNode head) {
        if (head == null || head.next == null)
            return head;
        //move the odd and even pointer by jumping one node.
        ListNode odd = head, even = head.next, evenHead = head.next;
        //even.next will be odd...odd should not be null,
        //coz even will be appended to odd in the end.
        while (even != null && even.next != null) {
            odd.next = odd.next.next;
            even.next = even.next.next;
            odd = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }

//**********************************************************************************//
11/15/17
Q11) Implement pow(x, n).
Input: 2.00000, 10  => 2^10
Output: 1024.00000
Input: 2.10000, 3 => 2.1^3
Output: 9.2610

    //time complex: O(logn) - > coz reducing the calc
    //by half in each call...
    public static  double myPow(double x, int n) {
        if(n==0)
            return 1;
        if(x==0)
            return 0;

        double half = myPow(x, n/2);
        // if power is even, just multiply halves n return
        if(n%2 ==0)
            return half* half;
            // if calling myPow(x, n/2)*myPow(x, n/2) ,then O(n)
        else {
            //odd powers..multiply halves and x..
            if(n>0){
                return x * half * half;
            } else {
                // negative pow...x^-1 => 1/x ..
                return  (1 / x) * half * half;
            }
        }
    }

//**********************************************************************************//
11/23/17
Q11) Remove Duplicates from Sorted Array

    public int removeDuplicates(int[] nums) {
        if(nums.length <=1)
            return nums.length;

        //starting from 1st index, keep adding unique
        //numbers..return this count.
        int i=0;
        for(int j=1;j<nums.length;j++){
            if(nums[i]==nums[j])continue;

            //else add to next place...non repeated chars..
            nums[++i]= nums[j];
        }
        //return count of unique numbers
        return i+1;
    }


