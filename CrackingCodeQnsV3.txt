
//**********************************************************************************//
11/14/17
Q1) Reverse String:
Write a function that takes a string as input and returns the string reversed.
Example:
Given s = "hello", return "olleh".

    public String reverseString(String s) {
        if (s == null || s.length() == 1)
            return s;

        char[] chars = s.toCharArray();
        StringBuilder sb = new StringBuilder();
        int len = chars.length;

        for (int i = len - 1; i >= 0; i--) {
            sb.append(chars[i]);
        }
        return sb.toString();
    }

//**********************************************************************************//
11/14/17
Q2) Longest Common Prefix
Write a function to find the longest common prefix string amongst an array of strings.

    public String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0)
            return "";
        if (strs.length == 1)
            return strs[0];

        int maxlen = Integer.MAX_VALUE;
        String min = null;
        //find the length of shortest string..
        // the answer cannot be longer than this.
        for (String str : strs) {
            if (str.length() < maxlen) {
                maxlen = str.length();
                min = str;
            }
        }
        //for 0 to maxlen,
        //check if char[i] is same for all strings,
        //else stop and return till last i;
        boolean end = false;
        for (int i = 0; i < maxlen; i++) {
            for (String str : strs) {
                if (min.charAt(i) != str.charAt(i)) {
                    end = true;
                    break;
                }
            }
            if (end) {
                if (i == 0) return "";
                else
                    return min.substring(0, i);
            }
        }
        return min;
    }

//**********************************************************************************//
11/14/17
Q3)Sum of two integers
Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example:
Given a = 1 and b = 2, return 3.

    public int getSum(int a, int b) {
        if (b == 0)
            return a;
        if (a == 0)
            return b;

        while (b != 0) {
            int carry = a & b;
            a = a ^ b;
            b = carry << 1;
        }

        return a;
    }

//**********************************************************************************//
11/14/17
Q4) Reverse an integer
Input: -123  Output: -321
Example 3: Input: 120 Output: 21

    public int reverse(int x) {
        // when reversing, it can be > int max value,
        //if so, return 0

        long rev = 0;
        while (x != 0) {
            rev = rev * 10 + x % 10;
            x = x / 10;
            //check if val > range, return 0;
            if (rev > Integer.MAX_VALUE || rev < Integer.MIN_VALUE)
                return 0;
        }
        return (int) rev;
    }

//**********************************************************************************//
11/14/17
Q5) Plus one
   inp -> [1,2,4] op-> [1,2,5], ip->[19], op-> [2,0]

    public int[] plusOne(int[] digits) {
        int len = digits.length;
        //traverse from the last digit,
        //if not 9, add one to it and send...
        for (int i = len - 1; i >= 0; i--) {
            if (digits[i] != 9) {
                digits[i] += 1;
                return digits;
            }
            //last digit is 9, make 0, carry over 1.
            // 1 is added by default, no need for carry.
            digits[i] = 0;
        }

        //if we have come here, it means array is all 9's..
        int[] ret = new int[len + 1];
        ret[0] = 1;

        return ret;
    }

//**********************************************************************************//
11/14/17
Q6) Number of 1 Bits

    public int hammingWeight(int n) {
        int count = 0;
        while(n!=0){
            count += (n&1);
            // use >>> for unsigned bit shifting
            // >> for signed bit shifting
            n = n>>>1;
        }
        return count;
    }

//**********************************************************************************//
11/14/17
Q7) Buy Sell stocks 2
Design an algorithm to find the maximum profit. You may complete as many transactions
 as you like (ie, buy one and sell one share of the stock multiple times). However, you may
  not engage in multiple transactions at the same time (ie, you must sell the stock before
   you buy again).
 eg: [2,1,2,0,1] -> 2
   [1,2,4] -> 3

    public int maxProfit(int[] prices) {
        int total = 0;
        for (int i = 0; i < prices.length - 1; i++) {
            if (prices[i + 1] > prices[i]) total += prices[i + 1] - prices[i];
        }
        return total;
    }

//**********************************************************************************//
11/15/17
Q8) Count and Say
 The first term is "1"
 Second term is "11", generated by reading first term as "One 1"
 (There is one 1 in previous term)
 Third term is "21", generated by reading second term as "Two 1"
 -> current value depends on n-1 value.


    public String countAndSay(int n) {
        if(n==1)
            return "1";

        String[] list = new String[n+1];
        list[1] = "1";
        list[2] = "11";

        //generate all combinations till n value..
        for(int i=3; i<=n;i++){
            char[] chars = list[i-1].toCharArray();
            int len = chars.length;
            int j = 0;
            StringBuffer sb = new StringBuffer();
            while(j<len-1){   //coz we are checking til j+1
                int cnt = 1;
                while(j<len-1 && chars[j] == chars[j+1]){j++;cnt++;}
                sb.append(cnt).append(chars[j]);
                j++; //move j to next char..will count in next loop.
                //if its the last character...
                if(j==len-1)
                    sb.append(1).append(chars[j]);
            }
            list[i] = sb.toString();
        }
        return list[n];
    }

//**********************************************************************************//
11/15/17
Q9) happy Number
Example: 19 is a happy number
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

    public static boolean isHappy(int n) {
        if (n == 1)
            return true;

        Set<Integer> set = new HashSet<>();
        int remain = 0;
        //repeat until product is unique..
        while (set.add(n)) {
            int sum = 0;
            while (n > 0) {
                remain = n % 10;
                sum += remain * remain;
                n = n / 10;
            }
            if (sum == 1)
                return true;
            else
                n = sum;
        }
        return false;
    }

//**********************************************************************************//
11/15/17
Q9) Factorial trailers zeros
Given an integer n, return the number of trailing zeroes in n!.

    public static int trailingZeroes(int n) {
        if(n==0)
            return 0;

        int zeros = 0;
        //Because all trailing 0 is from factors 5 * 2.
        //find n/5 + n/25 + n/125 ...
        while(n>0){
            zeros = zeros + n/5;
            n = n/5;
        }
        return zeros;
    }

//**********************************************************************************//
11/15/17
Q10) Odd even list
 Given a singly linked list, group all odd nodes together followed by the even nodes.
 Please note here we are talking about the node number and not the value in the nodes.

    public ListNode oddEvenList(ListNode head) {
        if (head == null || head.next == null)
            return head;
        //move the odd and even pointer by jumping one node.
        ListNode odd = head, even = head.next, evenHead = head.next;
        //even.next will be odd...odd should not be null,
        //coz even will be appended to odd in the end.
        while (even != null && even.next != null) {
            odd.next = odd.next.next;
            even.next = even.next.next;
            odd = odd.next;
            even = even.next;
        }
        odd.next = evenHead;
        return head;
    }

//**********************************************************************************//
11/15/17
Q11) Implement pow(x, n).
Input: 2.00000, 10  => 2^10
Output: 1024.00000
Input: 2.10000, 3 => 2.1^3
Output: 9.2610

    //time complex: O(logn) - > coz reducing the calc
    //by half in each call...
    public static  double myPow(double x, int n) {
        if(n==0)
            return 1;
        if(x==0)
            return 0;

        double half = myPow(x, n/2);
        // if power is even, just multiply halves n return
        if(n%2 ==0)
            return half* half;
            // if calling myPow(x, n/2)*myPow(x, n/2) ,then O(n)
        else {
            //odd powers..multiply halves and x..
            if(n>0){
                return x * half * half;
            } else {
                // negative pow...x^-1 => 1/x ..
                return  (1 / x) * half * half;
            }
        }
    }

//**********************************************************************************//
11/23/17
Q12) Remove Duplicates from Sorted Array

    public int removeDuplicates(int[] nums) {
        if(nums.length <=1)
            return nums.length;

        //starting from 1st index, keep adding unique
        //numbers..return this count.
        int i=0;
        for(int j=1;j<nums.length;j++){
            if(nums[i]==nums[j])continue;

            //else add to next place...non repeated chars..
            nums[++i]= nums[j];
        }
        //return count of unique numbers
        return i+1;
    }

//**********************************************************************************//
11/24/17
Q13) Group Anagrams
 For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"],
 Return: [
   ["ate", "eat","tea"],
   ["nat","tan"],
   ["bat"]
 ]
 
    public static List<List<String>> groupAnagrams(String[] strs) {

        if(strs==null|| strs.length==0)
            return new ArrayList<List<String>>();

        //store the strings as keys...sort and store..so anagrams
        // will be same string
        HashMap<String, List<String>> map = new HashMap<>();
        for(String str: strs){
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String sorted = String.valueOf(chars);
            if(!map.containsKey(sorted))
                map.put(sorted,new ArrayList<String>());
            map.get(sorted).add(str);
        }
        return new ArrayList<List<String>>(map.values());
    }

//**********************************************************************************//
11/25/17
Q14) Pascal Triangle
    For example, given numRows = 5,
    Return
    [
         [1],
        [1,1],
       [1,2,1],
      [1,3,3,1],
     [1,4,6,4,1]
    ]

    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> list = new ArrayList<>();
        if (numRows < 0)
            return list;

        for (int i = 0; i < numRows; i++) {
            ArrayList<Integer> row = new ArrayList<>();
            // j<i+1 , same no of columns as i.. 0 to i
            for (int j = 0; j < i+1; j++) {
                //add 1 to the first and last column
                if (j == 0 || j == i)
                    row.add(1);
                else {
                    //get previous row values..
                    row.add(list.get(i - 1).get(j - 1) + list.get(i - 1).get(j));
                }
            }
            list.add(row);
        }
        return list;
    }

//**********************************************************************************//
01/03/18
Q15) Island perimeter
ip:        int grid[][] = new int[][]
                   {{0,1,0,0},
                   {1,1,1,0},
                   {0,1,0,0},
                   {1,1,0,0}
op: 16

    public int islandPerimeter(int[][] grid) {
        if(grid==null|| grid.length ==0|| grid[0].length ==0) return 0;
        int col = grid[0].length;
        int row = grid.length;
        int per = 0;

        //check for the corner islands, no surrounding islands,
        // then add 1 to perimeter
        // do this for all the islands...
        for(int i=0; i<row; i++){
            for(int j=0;j<col;j++){
                if(grid[i][j] ==1){
                    if(i==0 || grid[i-1][j] ==0) per++;
                    if(i==row-1|| grid[i+1][j] ==0) per++;
                    if(j==0|| grid[i][j-1] ==0) per++;
                    if(j==col-1|| grid[i][j+1] ==0) per++;
                }
            }
        }
        return per;
    }

//**********************************************************************************//
01/03/18
Q16) Judge Route circle
    /*Initially, there is a Robot at position (0, 0).
    Given a sequence of its moves, judge if this robot makes a circle, which means it
    moves back to the original place.
    The move sequence is represented by a string. And each move is represent by a character.
     The valid robot moves are R (Right), L (Left), U (Up) and D (down).
      The output should be true or false representing whether the robot makes a circle
    Example 1:
    Input: "UD"
    Output: true*/

    public boolean judgeCircle(String moves) {
        int x=0, y=0;
        if(moves==null || moves.isEmpty())
            return false;

        for(char c: moves.toCharArray()){
            if(c == 'U') y++;
            else if(c == 'D') y--;
            else if(c == 'L') x--;
            else x++;
        }
        return (x==0 && y==0);
    }

//**********************************************************************************//
01/03/18
Q17) Power of three
    //check if a no is power of 3.

    public boolean isPower(int n){
        if(n<0) return false;
        while(n%3==0) n= n/3;
        return n==1;
    }

    public boolean isPowerRecursive(int n){
        return n>0 && (n==1 || ( n%3==0 && isPowerRecursive(n/3)));
    }
}

//**********************************************************************************//
01/03/18
Q18) First unique character in a string
Given a string, find the first non-repeating character in it and return it's index.
 If it doesn't exist, return -1.

 //using the ascii way for better performance instead of hashmap.
    public int firstUniqChar(String s) {
        if(s==null ||s.isEmpty()) return -1;

        //first add to list..increment for each character
        int[] chars = new int[26];
        for(char c: s.toCharArray()){
            chars[c-'a']++;
        }

        int idx = 0;
        for(char c: s.toCharArray()){
            if(chars[c-'a'] == 1)  return idx;
            idx++;
        }
        return -1;
    }

//**********************************************************************************//
01/03/18
Q19) Power of two..

    public boolean isPowerOfTwo(int n) {
        if(n<=0) return false;
        int cnt =0;
        while(n>0){
            cnt += (n & 1) == 1? 1 : 0;
            n = n>>1;
            if(cnt>1) return false;
        }
        return true;
    }

//**********************************************************************************//
01/03/18
Q20) Reverse vowels in a string
    Write a function that takes a string as input and reverse only the vowels of a string.
    Example 1:
    Given s = "hello", return "holle".
    Example 2:
    Given s = "leetcode", return "leotcede"

    public String reverseVowels(String str){
        if(str == null || str.isEmpty() || str.length() ==1) return str;

        int start=0, end = str.length()-1;
        char[] chars = str.toCharArray();
        final String VOWELS = "aeiouAEIOU";

        //use two pointers from both ends...if vowel is found,
        // interchange their values..
        while(start < end){

            //dont forget start<end condition
            while(start < end && VOWELS.indexOf(chars[start])==-1)
                start++;
            while(start < end && VOWELS.indexOf(chars[end])==-1)
                end--;

            char temp = chars[start];
            chars[start] = chars[end];
            chars[end] = temp;
            start++; end--;
        }
        return new String(chars);
    }

//**********************************************************************************//
01/03/18
Q21) Guess no higher or lower
We are playing the Guess Game. The game is as follows:
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I'll tell you whether the number is higher or lower.
You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):

    /* The guess API is defined in the parent class GuessGame.
   @param num, your guess
   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0
      int guess(int num); */

   public int guessNumber(int n) {
        int low=1, high = n;
        while(low<high){
            int mid = low + (high-low)/2;
            if(guess(mid)==0) return mid;

            if(guess(mid)==1)
                low=mid+1;
            else{
                high = mid;
            }
        }
        return n;
    }

//**********************************************************************************//
01/04/18
Q22) Encode and decode tiny url

public class EncodeDecodeTinyUrl {

    HashMap<String,String> keyIndex = new HashMap<>();
    String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyvz1234567890";
    static final String BASEURL = "http://tinyurl.com/";

    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        String key = null;
        do {
            StringBuilder sb = new StringBuilder();
            for(int i=0; i<6;i++){
                int idx = (int)Math.random() * chars.length();
                sb.append(chars.charAt(idx));
            }
            key = sb.toString();
        }while(keyIndex.containsKey(key));
        keyIndex.put(key, longUrl);
        return BASEURL+key;
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
        return keyIndex.get(shortUrl.replace(BASEURL,""));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));

//**********************************************************************************//
01/08/18
Q23) Merge Intervals

    /*Given a collection of intervals, merge all overlapping intervals.
    For example,
    Given [1,3],[2,6],[8,10],[15,18],
            return [1,6],[8,10],[15,18].*/

    public List<Interval> merge(List<Interval> intervals) {

        if(intervals == null || intervals.size()==1 || intervals.size()==0)
            return intervals;

        List<Interval> list = new ArrayList<>();

        //The idea is to sort the intervals by their starting points. Then, we take
        //the first interval and compare its end with the next intervals starts.
        //As long as they overlap, we update the end to be the max end of the
        //overlapping intervals. Once we find a non overlapping interval, we can add
        //the previous “extended” interval and start over.
        //Sorting takes O(n log(n)) and merging the intervals takes O(n).
         //So, the resulting algorithm takes O(n log(n)).

        intervals.sort(new Comparator<Interval>() {
            @Override
            public int compare(Interval o1, Interval o2) {
                return Integer.compare(o1.start,o2.start);
            }
        });
        int start =  intervals.get(0).start;
        int end =  intervals.get(0).end;

        for (Iterator<Interval> iterator = list.iterator(); iterator.hasNext(); ) {
            Interval next =  iterator.next();
            if(end >= next.start){
                end = Math.max(end,next.end);
            } else {
                list.add(new Interval(start, end));
                start = next.start;
                end = next.end;
            }
        }
        return list;
    }

//**********************************************************************************//
01/08/18
Q24) Binary Search Tree iterator

    //Implement an iterator over a binary search tree (BST). Your iterator will
    // be initialized with the root node of a BST.
    //Calling next() will return the next smallest number in the BST.
    //Note: next() and hasNext() should run in average O(1) time and uses
    // O(h) memory, where h is the height of the tree.

    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) {
            val = x;
        }
    }

    public class BSTIterator {

        TreeNode rootNode;
        List<Integer> list = new ArrayList<>();
        int index = 0;

        public BSTIterator(TreeNode root) {
            rootNode = root;
            getList(root);
        }

        // sort the node elements in ascending order using
        //inorder sort...
        public void getList(TreeNode node) {
            if (node != null) {
                getList(node.left);
                list.add(node.val);
                getList(node.right);
            }
        }
        /**
         * @return whether we have a next smallest number
         */
        public boolean hasNext() {
            if (index >= list.size()) return false;
            return true;
        }
        /**
         * @return the next smallest number
         */
        public int next() {
            return list.get(index++);
        }
    }