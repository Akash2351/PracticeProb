//**********************************************************************************//
02/13/18
Q1) Search in Rotated Sorted Array
Suppose an array sorted in ascending order is rotated at some pivot
unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
You are given a target value to search. If found in the array return its
index, otherwise return -1.You may assume no duplicate exists in the array.
-> Do it in O(logn) - > use binary search..

    public int search(int[] nums, int target) {
        if(nums==null || nums.length ==0)
            return -1;

        int low = 0, high = nums.length-1;
        while(low<=high){
            int mid = (low+high)/2;
            if(target == nums[mid])return mid;

            // the array is in proper order...sorted...check if no is in range
            //if yes, set the lower and upper bounds...
            if(nums[low]<=nums[mid]){  //4 5 6 7 0 1 2
                if(target>=nums[low] && target <nums[mid])
                    high = mid-1;
                else
                    low = mid+1;
            }

            if(nums[mid] <= nums[high]){  //4 5 6 0 1 2 3
                if(target>nums[mid] && target <= nums[high])
                    low = mid+1;
                else
                    high = mid-1;
            }
        }
        return -1;
    }

//**********************************************************************************//
02/13/18
Q2) Integer to Roman

    //Given an integer, convert it to a roman numeral.
    //Input is guaranteed to be within the range from 1 to 3999.
    public String intToRoman(int num) {

        //X->10, L->50, C->100,D->500, M->1000

        String[] ones = {"","I","II","III","IV","V","VI","VII","VIII","IX"};
        String[] tens = {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};
        String[] hundreds = {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};
        String[] thousands = {"","M","MM","MMM"};


        int one = num%10;
        int ten = (num%100)/10;
        int hundred = (num%1000)/100;
        int thousand = num/1000;

        //System.out.printf("%d %d %d %d",one,ten,hundred,thousand);
        return thousands[thousand]+hundreds[hundred]+tens[ten]+ones[one];
    }

//**********************************************************************************//
02/14/18
Q3) Flatten nested iterator

/*Given a nested list of integers, implement an iterator to flatten it.
Each element is either an integer, or a list -- whose elements may also be integers or other lists.
 Example 1:   Given the list [[1,1],2,[1,1]],
By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
 Example 2:    Given the list [1,[4,[6]]],
By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].*/

  // This is the interface that allows for creating nested lists.
  // You should not implement it, or speculate about its implementation
  interface NestedInteger {

      // @return true if this NestedInteger holds a single integer, rather than a nested list.
      public boolean isInteger();

      // @return the single integer that this NestedInteger holds, if it holds a single integer
      // Return null if this NestedInteger holds a nested list
      public Integer getInteger();
      // @return the nested list that this NestedInteger holds, if it holds a nested list
      // Return null if this NestedInteger holds a single integer
      public List<NestedInteger> getList();
  }

public class FlattenNestedIterator implements Iterator<Integer> {
    List<Integer> list = new ArrayList<>();
    int size =0;


    public FlattenNestedIterator(List<NestedInteger> nestedList) {
        addRecursively(nestedList,list);
        size = list.size();
        //returning from the end...so reverse the list
        Collections.reverse(list);
    }

    public void addRecursively(List<NestedInteger> nestedList, List<Integer> list){
        for(NestedInteger nInt: nestedList){
            if(nInt.isInteger()){
                list.add(nInt.getInteger());
            } else {
                addRecursively(nInt.getList(), list);
            }
        }
    }
    @Override
    public Integer next() {
        if(size > 0)
            return list.remove(--size);
        return null;
    }
    @Override
    public boolean hasNext() {
        if(size>0)return true;
        return false;
    }
}

//**********************************************************************************//
02/14/18
Q4) Unique Paths


/*    A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
    The robot can only move either down or right at any point in time.
    The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
    How many possible unique paths are there?  */

    public static int uniquePaths(int m, int n) {
        if(m==0 || n==0) return 0;

        int[][] table = new int[m][n];
        int rowLen = table.length, colLen = table[0].length;

        //initialize first row and column to 1's...only 1 way of going
        for(int i=0; i<rowLen; i++){
            table[i][0] = 1;
        }
        for(int i=0; i<colLen; i++){
            table[0][i] = 1;
        }

        //for any other entry, take the previous top and left  values and add them..
        //this gives all combinations for that particular cell.
        for(int i=1; i<rowLen; i++){
            for(int j=1; j<colLen;j++){
                table[i][j]=table[i-1][j]+table[i][j-1];
            }
        }
        return table[m-1][n-1];
    }

//**********************************************************************************//
02/14/18
Q5) Trim BST

//Given a binary search tree and the lowest and highest boundaries
// as L and R, trim the tree so that all its elements lies in [L, R] (R >= L).
// You might need to change the root of the tree, so the result should
// return the new root of the trimmed binary search tree.

/*Input:
           3
         /  \
        0   4
         \
          2
        /
      1
        L = 1
        R = 3
        Output:
            3
           /
          2
        /
       1 */

public class TrimBST {
    public TreeNode trimBST(TreeNode root, int L, int R) {
        if(root==null)
            return root;

        //if node is within range, call recursively..for left and right
        if(root.val>=L && root.val<=R){
            root.left = trimBST(root.left,L,R);
            root.right = trimBST(root.right,L,R);
            return root;
        }
        //if node not within range, call its left or right child accordingly
        else if(root.val < L){
            return trimBST(root.right,L,R);
        } else {
            return trimBST(root.left, L,R);
        }
    }
}

//**********************************************************************************//
02/15/18
Q6) Friend circles

/*There are N students in a class. Some of them are friends, while some are not.
    Their friendship is transitive in nature. For example, if A is a direct
    friend of B, and B is a direct friend of C, then A is an indirect friend of C.
    And we defined a friend circle is a group of students who are direct or indirect friends.
Given a N*N matrix M representing the friend relationship between students in the class.
    If M[i][j] = 1, then the ith and jth students are direct friends with each other,
    otherwise not. And you have to output the total number of friend
    circles among all the students.

   Input:
   [[1,1,0],
   [1,1,0],
   [0,0,1]]
    Output: 2  */

    public int findCircleNum(int[][] M) {
        int circleCount = 0;
        int rowLen = M.length;

        //same like island count...use dfs to recursively find friends
        // and make their entry 0.
        for(int i=0;i<rowLen; i++)
            for(int j=0; j<rowLen; j++){
                if(M[i][j] == 1){
                    dfs(M,i,j);
                    circleCount++;
                }
            }

        return circleCount;
    }

    public void dfs(int[][] M, int i, int j){
        if(M[i][j] == 0) return;
        M[i][j] = 0;

        //make all friends of i and j 0's recursively
        for(int k=0; k<M.length; k++){
            if(M[i][k] == 1) dfs(M, i,k);
            if(M[k][i] == 1) dfs(M, k,i);
            if(M[j][k] == 1) dfs(M, j,k);
            if(M[k][j] == 1) dfs(M, k,j);
        }
    }

//**********************************************************************************//
02/15/18
Q7) House Robber 3

/*The thief has found himself a new place for his thievery again.
    There is only one entrance to this area, called the "root." Besides
    the root, each house has one and only one parent house. After a tour,
    the smart thief realized that "all houses in this place forms a binary tree".
    It will automatically contact the police if two directly-linked houses were
    broken into on the same night.

Determine the maximum amount of money the thief can rob tonight
    without alerting the police.

                  3
                 / \
                4   5
               / \   \
              1   3   1
 Maximum amount of money the thief can rob = 4 + 5 = 9.*/

    public int rob(TreeNode root){
        if(root== null) return 0;

        if(root.left == null && root.right==null)
            return root.val;

        //consider the rob case...
        //rob = root + left child's grandchildren + right child's grandchildren
        int rob = root.val;
        int grandChildLeft = 0, grandChildRight = 0;
        if(root.left!=null)
            grandChildLeft = rob(root.left.left) + rob(root.left.right);
        if(root.right!=null)
            grandChildRight = rob(root.right.left) + rob(root.right.right);

        rob += grandChildLeft + grandChildRight;

        //consider not rob case...
        //not rob = left child + right child called recursively
        int notRob = rob(root.left) + rob(root.right);

        return Math.max(rob, notRob);
    }

//**********************************************************************************//
02/17/18
Q8) Linked List cycle 2

//Given a linked list, return the node where the cycle begins.
// If there is no cycle, return null.
// Note: Do not modify the linked list.
    public ListNode detectCycle(ListNode head) {

        if(head == null)
            return null;

        ListNode slow = head,fast = head;
        ListNode cycle = null;
        while(slow!=null && fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;

            if(slow==fast){
                //cycle detected...
                cycle = head;
                //move head and slow one node at a time
                //when they are the same, its the entry of the cycle.
                while(cycle != slow){
                    slow = slow.next;
                    cycle = cycle.next;
                }
                return cycle;
            }
        }
        return cycle;
    }

//**********************************************************************************//
02/17/18
Q9) Rotate linked list.

    /*Given a list, rotate the list to the right by k places, where k is non-negative.
    Example:
    Given 1->2->3->4->5->NULL and k = 2,
    return 4->5->1->2->3->NULL.*/
    public ListNode rotateRight(ListNode head, int k) {

        if (head == null) return head;
        //if there is only 1 node, any k will return same list...
        if (k == 0 || head.next == null) return head;

        ListNode temp = new ListNode(0);
        temp.next = head;
        ListNode first = temp, second = temp;

        //calculate the len of list...coz k might be greater than len..use %
        ListNode dummy = head;
        int len = 0;
        while (dummy != null) {
            dummy = dummy.next;
            len++;
        }

        k = k % len;
        if (k == 0)
            return head;

        //move first pointer k nodes from head...
        //later move first and second till first reached end...
        //now break n join ends....
        while (k > 0) {
            first = first.next;
            k--;
        }

        //if first reaches end, full list is rotated..so return head.
        if (first.next == null)
            return head;

        while (first.next != null) {
            first = first.next;
            second = second.next;
        }

        //eg [1,2,3,4,5] , k=2 : first-5, second-3.
        // start list from 4..i.e second.next...break list s.next = null.
        ListNode newHead = second.next;
        second.next = null;
        first.next = head;
        return newHead;
    }

//**********************************************************************************//
02/18/18
Q10) Rotate Array.
//Rotate an array of n elements to the right by k steps.
//For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7]
// is rotated to [5,6,7,1,2,3,4].

    public void rotate(int[] nums, int k) {
        k = k%nums.length;

        //reverse array approach:
        /* 1)we have to first reverse the whole array by swapping
         first element with the last one and so on…
        you will get[7,6,5,4,3,2,1]

        2)reverse the elements from 0 to k-1
        reverse the elements 7,6,5
        you will get [5,6,7,4,3,2,1]

        3)reverse the elements from k to n-1
        reverse the elements 4,3,2,1
        you will get[5,6,7,1,2,3,4]*/

        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);

        //second approach...using new array...
        int[] copy = nums.clone();
        for(int i=0; i<copy.length;i++){
            nums[ (i+k)%copy.length] = copy[i];
        }
    }

    public void reverse(int[] ary, int start, int end){
        while(start< end){
            int temp = ary[start];
            ary[start] = ary[end];
            ary[end] = temp;
            start++; end--;
        }
    }

//**********************************************************************************//
02/18/18
Q11) Permutation in String.
/*Given two strings s1 and s2, write a function to return true if s2 contains
    the permutation of s1. In other words, one of the first string's
    permutations is the substring of the second string.
Example 1:
Input:s1 = "ab" s2 = "eidbaooo"
Output:True
Explanation: s2 contains one permutation of s1 ("ba").
Example 2:
Input:s1= "ab" s2 = "eidboaoo"
Output: False*/

    public boolean checkInclusion(String s1, String s2) {
        if(s1 == null || s1.isEmpty()) return true;
        if(s2 == null || s1.length() > s2.length()) return false;

        //use the sliding window approach..similar to other problem...
        //indices of string where anagram is found...

        int len1 = s1.length(), len2 = s2.length();
        for(int i=0;i<len2; i++){
            if(i+len1 > len2 )break;
            if(isAnagram(s1,s2.substring(i,i+len1)))
                return true;
        }
        return false;
    }

    public boolean isAnagram(String s1, String s2){
        int[] dict = new int[26];
        for(char c: s1.toCharArray())
            dict[c - 'a']++;
        for(char c: s2.toCharArray()) {
            dict[c - 'a']--;
            if (dict[c - 'a'] < 0) return false;
        }
        return true;
    }

//**********************************************************************************//
02/18/18
Q12) Subsets.
/*Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
For example,
 If nums = [1,2,3], a solution is:
            [
            [3],
            [1],
            [2],
            [1,2,3],
            [1,3],
            [2,3],
            [1,2],
            []
            ] */


    //same like permutation, phone no problem...
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        if(nums.length == 0) return list;

        generateRecursive(nums.length,0, nums, new ArrayList<Integer>(),list);
        list.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));
        return list;
    }

    public void generateRecursive(int len,int index, int[] nums, List<Integer> cur,
            List<List<Integer>> list){
        if(len <= 0 ) return;
        //keep adding all combinations...
        list.add(new ArrayList<Integer>(cur));

        for(int i=index; i<nums.length; i++){
            if(!cur.contains(nums[i])){
                cur.add(nums[i]);
                generateRecursive(len-1,i+1,nums,cur,list);
                cur.remove(cur.size()-1);
            }
        }
    }

//**********************************************************************************//
02/18/18
Q13) Target Sum

/*You are given a list of non-negative integers, a1, a2, ..., an, and a target, S.
    Now you have 2 symbols + and -. For each integer, you should choose
    one from + and - as its new symbol.
Find out how many ways to assign symbols to make sum of integers equal to target S.
 Example 1:
Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:
            -1+1+1+1+1 = 3
            +1-1+1+1+1 = 3
            +1+1-1+1+1 = 3
            +1+1+1-1+1 = 3
            +1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.*/

    static int count = 0;
    public static int findTargetSumWays(int[] nums, int S) {
        calculate(nums, 0, 0, S);
        return count;
    }
    public static void calculate(int[] nums, int i, int sum, int S) {
        if (i == nums.length) {
            if (sum == S)
                count++;
        } else {
            calculate(nums, i + 1, sum + nums[i], S);
            calculate(nums, i + 1, sum - nums[i], S);
        }
    }

//**********************************************************************************//
02/20/18
Q14) Excel Column sheet number
/*Given a column title as appear in an Excel sheet, return its
    corresponding column number.
    For example:
    A -> 1
    B -> 2
            ...
    Z -> 26
    AA -> 27
    AB -> 28*/

    public int titleToNumber(String s) {
        //AB case
        // 1*26 + 1+ 1 = 28

        int col = 0;
        for(int i=0; i<s.length(); i++){
            col = col * 26 + (s.charAt(i) - 'A')+1;
        }
        return col;
    }

//**********************************************************************************//
02/20/18
Q15) Excel Column Title
/*  Given a positive integer, return its corresponding column
    title as appear in an Excel sheet.
    For example:
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB*/

    public String convertToTitle(int n) {
        StringBuilder result = new StringBuilder();
        while (n > 0) {
            n--;
            result.append((char)('A' + n % 26)); //range is from 0-25
            n /= 26;
        }
        result.reverse();
        return result.toString();
    }

//**********************************************************************************//
02/21/18
Q16) Intersection of 2 arrays

/*Given two arrays, write a function to compute their intersection.
Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].  */

    public int[] intersect(int[] nums1, int[] nums2) {
        if(nums1.length == 0 || nums2.length == 0) return new int[]{};
        List<Integer> list = new ArrayList<>();

        HashMap<Integer,Integer> map = new HashMap<>();
        for(int n:nums1){
            map.put(n, map.getOrDefault(n,0)+1);
        }

        for(int n: nums2){
            if(map.get(n) != null && map.get(n)>0){
                map.put(n,map.get(n)-1);
                list.add(n);
            }
        }

        int[] res = new int[list.size()];
        for(int i=0;i<list.size();i++){
            res[i] = list.get(i);
        }
        return res;
    }

//**********************************************************************************//
02/21/18
Q17) sorted array to BST

/*Given an array where elements are sorted in ascending order
    convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined
    as a binary tree in which the depth of the two subtrees of
    every node never differ by more than 1.*/

    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums.length == 0) return null;
        return getBST(nums,0,nums.length-1);
    }

    public TreeNode getBST(int[] nums, int start, int end){
        if(start<= end){   //note <= ...not <
            int mid = (start + end )/2;
            TreeNode node = new TreeNode(nums[mid]);
            node.left= getBST(nums,start, mid-1);
            node.right = getBST(nums, mid+1, end);
            return node;
        }
        return null;

    }

//**********************************************************************************//
02/21/18
Q18) Sorted list to BST

/*Given an sorted linked list where elements are sorted in ascending order
    convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined
    as a binary tree in which the depth of the two subtrees of
    every node never differ by more than 1.*/


    public TreeNode sortedListToBST(ListNode head) {
        if(head == null) return null;
        int[] nums = getIntArray(head);
        return getBST(nums,0, nums.length-1);
    }

    public int[] getIntArray(ListNode head){
        List<Integer> list = new ArrayList<>();
        while(head!=null){
            list.add(head.val);
            head = head.next;
        }

        int res[] = new int[list.size()];
        for(int i=0; i<list.size();i++)
            res[i] = list.get(i);

       return res;
    }

        public TreeNode getBST(int[] nums, int start, int end){
        if(start<= end){  //note <= ...
            int mid = (start + end )/2;
            TreeNode node = new TreeNode(nums[mid]);
            node.left= getBST(nums,start, mid-1);
            node.right = getBST(nums, mid+1, end);
            return node;
        }
        return null;

    }

//**********************************************************************************//
02/21/18
Q19) Add two number 2

/* You are given two non-empty linked lists representing two non-negative
 integers. The most significant digit comes first and each of their nodes
  contain a single digit. Add the two numbers and return it as a linked list.
  You may assume the two numbers do not contain any leading zero,
  except the number 0 itself.
  Follow up:
  What if you cannot modify the input lists? In other words, reversing the
  lists is not allowed.
  Example:
  Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
  Output: 7 -> 8 -> 0 -> 7 */

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        List<Integer> list1 = new ArrayList<>();
        List<Integer> list2 = new ArrayList<>();
        List<Integer> list = new ArrayList<>();

        //idea is to store the values in list, traverse from end,
        //add to new list...reverse the final list, make linked list
        //and return.
        while (l1 != null) {
            list1.add(l1.val);
            l1 = l1.next;
        }
        while (l2 != null) {
            list2.add(l2.val);
            l2 = l2.next;
        }
        List<Integer> maxList, minList;
        if (list1.size() > list2.size()) {
            maxList = list1;
            minList = list2;
        } else {
            maxList = list2;
            minList = list1;
        }

        int carry = 0, minlen = minList.size(), maxlen = maxList.size();
        for (int i = 0; i < maxlen; i++) {
            int sum = minlen > i ? minList.get(minlen - 1 - i) + maxList.get(maxlen - 1 - i) :
                    maxList.get(maxlen - 1 - i);
            sum += carry;
            carry = sum / 10;
            sum = sum % 10;
            list.add(sum);
        }
        if (carry > 0)
            list.add(carry);

        reverse(list);
        ListNode prev = null, cur = null;
        ListNode head = new ListNode(list.get(0));
        prev = head;
        for (int i = 1; i < list.size(); i++) {
            cur = new ListNode(list.get(i));
            prev.next = cur;
            prev = cur;
        }
        return head;
    }

//**********************************************************************************//
02/22/18
Q20) String to integer

/*The function first discards as many whitespace characters as necessary
    until the first non-whitespace character is found. Then, starting from
    this character, takes an optional initial plus or minus sign followed
    by as many numerical digits as possible, and interprets them as a numerical value.
The string can contain additional characters after those that form the
    integral number, which are ignored and have no effect on the
    behavior of this function.
If the first sequence of non-whitespace characters in str is not a valid integral
    number, or if no such sequence exists because either str is empty or it contains
    only whitespace characters, no conversion is performed.
If no valid conversion could be performed, a zero value is returned.
    If the correct value is out of the range of representable values,
    INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.*/

    public static int myAtoi(String str) {
        int ret =0;
        int sign = 1;
        str = str.trim();
        List<Integer> list = new ArrayList<>();

        for(int i=0; i<str.length(); i++){
            char c = str.charAt(i);
            //only + or - can be at the beginning, +-2 is invalid
            if(i ==0 && c == '-') {sign =-1;list.add(0);}
            else if(i==0 && c == '+') {sign =1; list.add(0);}
            //from i=1, numbers should start, else invalid, return 0
            else if(i>0 && list.size()==0 && (c < '0' && c >'9')) return 0;
            else if( c >= '0' && c <='9'){
                list.add( c - '0');
            }
            //eliminate the invalid chars at the end..
            else break;
        }

        long mult = 0;
        for(int i=list.size()-1; i>=0;i--){
            //traverse from the end..multiple with powers of 10..
            long m = (long)Math.pow(10,mult);
            mult++;

            if(ret + (list.get(i) * m) > Integer.MAX_VALUE) {
                if(sign == -1) return Integer.MIN_VALUE;
                else return Integer.MAX_VALUE;
            }
            ret += list.get(i)*m;
        }
        ret *= sign;
        return ret;
    }