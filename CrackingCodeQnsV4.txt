//**********************************************************************************//
02/13/18
Q1) Search in Rotated Sorted Array
Suppose an array sorted in ascending order is rotated at some pivot
unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
You are given a target value to search. If found in the array return its
index, otherwise return -1.You may assume no duplicate exists in the array.
-> Do it in O(logn) - > use binary search..

    public int search(int[] nums, int target) {
        if(nums==null || nums.length ==0)
            return -1;

        int low = 0, high = nums.length-1;
        while(low<=high){
            int mid = (low+high)/2;
            if(target == nums[mid])return mid;

            // the array is in proper order...sorted...check if no is in range
            //if yes, set the lower and upper bounds...
            if(nums[low]<=nums[mid]){  //4 5 6 7 0 1 2
                if(target>=nums[low] && target <nums[mid])
                    high = mid-1;
                else
                    low = mid+1;
            }

            if(nums[mid] <= nums[high]){  //4 5 6 0 1 2 3
                if(target>nums[mid] && target <= nums[high])
                    low = mid+1;
                else
                    high = mid-1;
            }
        }
        return -1;
    }

//**********************************************************************************//
02/13/18
Q2) Integer to Roman

    //Given an integer, convert it to a roman numeral.
    //Input is guaranteed to be within the range from 1 to 3999.
    public String intToRoman(int num) {

        //X->10, L->50, C->100,D->500, M->1000

        String[] ones = {"","I","II","III","IV","V","VI","VII","VIII","IX"};
        String[] tens = {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};
        String[] hundreds = {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};
        String[] thousands = {"","M","MM","MMM"};


        int one = num%10;
        int ten = (num%100)/10;
        int hundred = (num%1000)/100;
        int thousand = num/1000;

        //System.out.printf("%d %d %d %d",one,ten,hundred,thousand);
        return thousands[thousand]+hundreds[hundred]+tens[ten]+ones[one];
    }

//**********************************************************************************//
02/14/18
Q3) Flatten nested iterator

/*Given a nested list of integers, implement an iterator to flatten it.
Each element is either an integer, or a list -- whose elements may also be integers or other lists.
 Example 1:   Given the list [[1,1],2,[1,1]],
By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
 Example 2:    Given the list [1,[4,[6]]],
By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].*/

  // This is the interface that allows for creating nested lists.
  // You should not implement it, or speculate about its implementation
  interface NestedInteger {

      // @return true if this NestedInteger holds a single integer, rather than a nested list.
      public boolean isInteger();

      // @return the single integer that this NestedInteger holds, if it holds a single integer
      // Return null if this NestedInteger holds a nested list
      public Integer getInteger();
      // @return the nested list that this NestedInteger holds, if it holds a nested list
      // Return null if this NestedInteger holds a single integer
      public List<NestedInteger> getList();
  }

public class FlattenNestedIterator implements Iterator<Integer> {
    List<Integer> list = new ArrayList<>();
    int size =0;


    public FlattenNestedIterator(List<NestedInteger> nestedList) {
        addRecursively(nestedList,list);
        size = list.size();
        //returning from the end...so reverse the list
        Collections.reverse(list);
    }

    public void addRecursively(List<NestedInteger> nestedList, List<Integer> list){
        for(NestedInteger nInt: nestedList){
            if(nInt.isInteger()){
                list.add(nInt.getInteger());
            } else {
                addRecursively(nInt.getList(), list);
            }
        }
    }
    @Override
    public Integer next() {
        if(size > 0)
            return list.remove(--size);
        return null;
    }
    @Override
    public boolean hasNext() {
        if(size>0)return true;
        return false;
    }
}

//**********************************************************************************//
02/14/18
Q4) Unique Paths


/*    A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
    The robot can only move either down or right at any point in time.
    The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
    How many possible unique paths are there?  */

    public static int uniquePaths(int m, int n) {
        if(m==0 || n==0) return 0;

        int[][] table = new int[m][n];
        int rowLen = table.length, colLen = table[0].length;

        //initialize first row and column to 1's...only 1 way of going
        for(int i=0; i<rowLen; i++){
            table[i][0] = 1;
        }
        for(int i=0; i<colLen; i++){
            table[0][i] = 1;
        }

        //for any other entry, take the previous top and left  values and add them..
        //this gives all combinations for that particular cell.
        for(int i=1; i<rowLen; i++){
            for(int j=1; j<colLen;j++){
                table[i][j]=table[i-1][j]+table[i][j-1];
            }
        }
        return table[m-1][n-1];
    }

//**********************************************************************************//
02/14/18
Q5) Trim BST

//Given a binary search tree and the lowest and highest boundaries
// as L and R, trim the tree so that all its elements lies in [L, R] (R >= L).
// You might need to change the root of the tree, so the result should
// return the new root of the trimmed binary search tree.

/*Input:
           3
         /  \
        0   4
         \
          2
        /
      1
        L = 1
        R = 3
        Output:
            3
           /
          2
        /
       1 */

public class TrimBST {
    public TreeNode trimBST(TreeNode root, int L, int R) {
        if(root==null)
            return root;

        //if node is within range, call recursively..for left and right
        if(root.val>=L && root.val<=R){
            root.left = trimBST(root.left,L,R);
            root.right = trimBST(root.right,L,R);
            return root;
        }
        //if node not within range, call its left or right child accordingly
        else if(root.val < L){
            return trimBST(root.right,L,R);
        } else {
            return trimBST(root.left, L,R);
        }
    }
}

//**********************************************************************************//
02/15/18
Q6) Friend circles

/*There are N students in a class. Some of them are friends, while some are not.
    Their friendship is transitive in nature. For example, if A is a direct
    friend of B, and B is a direct friend of C, then A is an indirect friend of C.
    And we defined a friend circle is a group of students who are direct or indirect friends.
Given a N*N matrix M representing the friend relationship between students in the class.
    If M[i][j] = 1, then the ith and jth students are direct friends with each other,
    otherwise not. And you have to output the total number of friend
    circles among all the students.

   Input:
   [[1,1,0],
   [1,1,0],
   [0,0,1]]
    Output: 2  */

    public int findCircleNum(int[][] M) {
        int circleCount = 0;
        int rowLen = M.length;

        //same like island count...use dfs to recursively find friends
        // and make their entry 0.
        for(int i=0;i<rowLen; i++)
            for(int j=0; j<rowLen; j++){
                if(M[i][j] == 1){
                    dfs(M,i,j);
                    circleCount++;
                }
            }

        return circleCount;
    }

    public void dfs(int[][] M, int i, int j){
        if(M[i][j] == 0) return;
        M[i][j] = 0;

        //make all friends of i and j 0's recursively
        for(int k=0; k<M.length; k++){
            if(M[i][k] == 1) dfs(M, i,k);
            if(M[k][i] == 1) dfs(M, k,i);
            if(M[j][k] == 1) dfs(M, j,k);
            if(M[k][j] == 1) dfs(M, k,j);
        }
    }

//**********************************************************************************//
02/15/18
Q7) House Robber 3

/*The thief has found himself a new place for his thievery again.
    There is only one entrance to this area, called the "root." Besides
    the root, each house has one and only one parent house. After a tour,
    the smart thief realized that "all houses in this place forms a binary tree".
    It will automatically contact the police if two directly-linked houses were
    broken into on the same night.

Determine the maximum amount of money the thief can rob tonight
    without alerting the police.

                  3
                 / \
                4   5
               / \   \
              1   3   1
 Maximum amount of money the thief can rob = 4 + 5 = 9.*/

    public int rob(TreeNode root){
        if(root== null) return 0;

        if(root.left == null && root.right==null)
            return root.val;

        //consider the rob case...
        //rob = root + left child's grandchildren + right child's grandchildren
        int rob = root.val;
        int grandChildLeft = 0, grandChildRight = 0;
        if(root.left!=null)
            grandChildLeft = rob(root.left.left) + rob(root.left.right);
        if(root.right!=null)
            grandChildRight = rob(root.right.left) + rob(root.right.right);

        rob += grandChildLeft + grandChildRight;

        //consider not rob case...
        //not rob = left child + right child called recursively
        int notRob = rob(root.left) + rob(root.right);

        return Math.max(rob, notRob);
    }

//**********************************************************************************//
02/17/18
Q8) Linked List cycle 2

//Given a linked list, return the node where the cycle begins.
// If there is no cycle, return null.
// Note: Do not modify the linked list.
    public ListNode detectCycle(ListNode head) {

        if(head == null)
            return null;

        ListNode slow = head,fast = head;
        ListNode cycle = null;
        while(slow!=null && fast!=null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;

            if(slow==fast){
                //cycle detected...
                cycle = head;
                //move head and slow one node at a time
                //when they are the same, its the entry of the cycle.
                while(cycle != slow){
                    slow = slow.next;
                    cycle = cycle.next;
                }
                return cycle;
            }
        }
        return cycle;
    }

//**********************************************************************************//
02/17/18
Q9) Rotate linked list.

    /*Given a list, rotate the list to the right by k places, where k is non-negative.
    Example:
    Given 1->2->3->4->5->NULL and k = 2,
    return 4->5->1->2->3->NULL.*/
    public ListNode rotateRight(ListNode head, int k) {

        if (head == null) return head;
        //if there is only 1 node, any k will return same list...
        if (k == 0 || head.next == null) return head;

        ListNode temp = new ListNode(0);
        temp.next = head;
        ListNode first = temp, second = temp;

        //calculate the len of list...coz k might be greater than len..use %
        ListNode dummy = head;
        int len = 0;
        while (dummy != null) {
            dummy = dummy.next;
            len++;
        }

        k = k % len;
        if (k == 0)
            return head;

        //move first pointer k nodes from head...
        //later move first and second till first reached end...
        //now break n join ends....
        while (k > 0) {
            first = first.next;
            k--;
        }

        //if first reaches end, full list is rotated..so return head.
        if (first.next == null)
            return head;

        while (first.next != null) {
            first = first.next;
            second = second.next;
        }

        //eg [1,2,3,4,5] , k=2 : first-5, second-3.
        // start list from 4..i.e second.next...break list s.next = null.
        ListNode newHead = second.next;
        second.next = null;
        first.next = head;
        return newHead;
    }

//**********************************************************************************//
02/18/18
Q10) Rotate Array.
//Rotate an array of n elements to the right by k steps.
//For example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7]
// is rotated to [5,6,7,1,2,3,4].

    public void rotate(int[] nums, int k) {
        k = k%nums.length;

        //reverse array approach:
        /* 1)we have to first reverse the whole array by swapping
         first element with the last one and so on…
        you will get[7,6,5,4,3,2,1]

        2)reverse the elements from 0 to k-1
        reverse the elements 7,6,5
        you will get [5,6,7,4,3,2,1]

        3)reverse the elements from k to n-1
        reverse the elements 4,3,2,1
        you will get[5,6,7,1,2,3,4]*/

        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);

        //second approach...using new array...
        int[] copy = nums.clone();
        for(int i=0; i<copy.length;i++){
            nums[ (i+k)%copy.length] = copy[i];
        }
    }

    public void reverse(int[] ary, int start, int end){
        while(start< end){
            int temp = ary[start];
            ary[start] = ary[end];
            ary[end] = temp;
            start++; end--;
        }
    }

//**********************************************************************************//
02/18/18
Q11) Permutation in String.
/*Given two strings s1 and s2, write a function to return true if s2 contains
    the permutation of s1. In other words, one of the first string's
    permutations is the substring of the second string.
Example 1:
Input:s1 = "ab" s2 = "eidbaooo"
Output:True
Explanation: s2 contains one permutation of s1 ("ba").
Example 2:
Input:s1= "ab" s2 = "eidboaoo"
Output: False*/

    public boolean checkInclusion(String s1, String s2) {
        if(s1 == null || s1.isEmpty()) return true;
        if(s2 == null || s1.length() > s2.length()) return false;

        //use the sliding window approach..similar to other problem...
        //indices of string where anagram is found...

        int len1 = s1.length(), len2 = s2.length();
        for(int i=0;i<len2; i++){
            if(i+len1 > len2 )break;
            if(isAnagram(s1,s2.substring(i,i+len1)))
                return true;
        }
        return false;
    }

    public boolean isAnagram(String s1, String s2){
        int[] dict = new int[26];
        for(char c: s1.toCharArray())
            dict[c - 'a']++;
        for(char c: s2.toCharArray()) {
            dict[c - 'a']--;
            if (dict[c - 'a'] < 0) return false;
        }
        return true;
    }

//**********************************************************************************//
02/18/18
Q12) Subsets.
/*Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
For example,
 If nums = [1,2,3], a solution is:
            [
            [3],
            [1],
            [2],
            [1,2,3],
            [1,3],
            [2,3],
            [1,2],
            []
            ] */


    //same like permutation, phone no problem...
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> list = new ArrayList<>();
        if(nums.length == 0) return list;

        generateRecursive(nums.length,0, nums, new ArrayList<Integer>(),list);
        list.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));
        return list;
    }

    public void generateRecursive(int len,int index, int[] nums, List<Integer> cur,
            List<List<Integer>> list){
        if(len <= 0 ) return;
        //keep adding all combinations...
        list.add(new ArrayList<Integer>(cur));

        for(int i=index; i<nums.length; i++){
            if(!cur.contains(nums[i])){
                cur.add(nums[i]);
                generateRecursive(len-1,i+1,nums,cur,list);
                cur.remove(cur.size()-1);
            }
        }
    }

//**********************************************************************************//
02/18/18
Q13) Target Sum

/*You are given a list of non-negative integers, a1, a2, ..., an, and a target, S.
    Now you have 2 symbols + and -. For each integer, you should choose
    one from + and - as its new symbol.
Find out how many ways to assign symbols to make sum of integers equal to target S.
 Example 1:
Input: nums is [1, 1, 1, 1, 1], S is 3.
Output: 5
Explanation:
            -1+1+1+1+1 = 3
            +1-1+1+1+1 = 3
            +1+1-1+1+1 = 3
            +1+1+1-1+1 = 3
            +1+1+1+1-1 = 3

There are 5 ways to assign symbols to make the sum of nums be target 3.*/

    static int count = 0;
    public static int findTargetSumWays(int[] nums, int S) {
        calculate(nums, 0, 0, S);
        return count;
    }
    public static void calculate(int[] nums, int i, int sum, int S) {
        if (i == nums.length) {
            if (sum == S)
                count++;
        } else {
            calculate(nums, i + 1, sum + nums[i], S);
            calculate(nums, i + 1, sum - nums[i], S);
        }
    }

//**********************************************************************************//
02/20/18
Q14) Excel Column sheet number
/*Given a column title as appear in an Excel sheet, return its
    corresponding column number.
    For example:
    A -> 1
    B -> 2
            ...
    Z -> 26
    AA -> 27
    AB -> 28*/

    public int titleToNumber(String s) {
        //AB case
        // 1*26 + 1+ 1 = 28

        int col = 0;
        for(int i=0; i<s.length(); i++){
            col = col * 26 + (s.charAt(i) - 'A')+1;
        }
        return col;
    }

//**********************************************************************************//
02/20/18
Q15) Excel Column Title
/*  Given a positive integer, return its corresponding column
    title as appear in an Excel sheet.
    For example:
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB*/

    public String convertToTitle(int n) {
        StringBuilder result = new StringBuilder();
        while (n > 0) {
            n--;
            result.append((char)('A' + n % 26)); //range is from 0-25
            n /= 26;
        }
        result.reverse();
        return result.toString();
    }

//**********************************************************************************//
02/21/18
Q16) Intersection of 2 arrays

/*Given two arrays, write a function to compute their intersection.
Example:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].  */

    public int[] intersect(int[] nums1, int[] nums2) {
        if(nums1.length == 0 || nums2.length == 0) return new int[]{};
        List<Integer> list = new ArrayList<>();

        HashMap<Integer,Integer> map = new HashMap<>();
        for(int n:nums1){
            map.put(n, map.getOrDefault(n,0)+1);
        }

        for(int n: nums2){
            if(map.get(n) != null && map.get(n)>0){
                map.put(n,map.get(n)-1);
                list.add(n);
            }
        }

        int[] res = new int[list.size()];
        for(int i=0;i<list.size();i++){
            res[i] = list.get(i);
        }
        return res;
    }

//**********************************************************************************//
02/21/18
Q17) sorted array to BST

/*Given an array where elements are sorted in ascending order
    convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined
    as a binary tree in which the depth of the two subtrees of
    every node never differ by more than 1.*/

    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums.length == 0) return null;
        return getBST(nums,0,nums.length-1);
    }

    public TreeNode getBST(int[] nums, int start, int end){
        if(start<= end){   //note <= ...not <
            int mid = (start + end )/2;
            TreeNode node = new TreeNode(nums[mid]);
            node.left= getBST(nums,start, mid-1);
            node.right = getBST(nums, mid+1, end);
            return node;
        }
        return null;

    }

//**********************************************************************************//
02/21/18
Q18) Sorted list to BST

/*Given an sorted linked list where elements are sorted in ascending order
    convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined
    as a binary tree in which the depth of the two subtrees of
    every node never differ by more than 1.*/


    public TreeNode sortedListToBST(ListNode head) {
        if(head == null) return null;
        int[] nums = getIntArray(head);
        return getBST(nums,0, nums.length-1);
    }

    public int[] getIntArray(ListNode head){
        List<Integer> list = new ArrayList<>();
        while(head!=null){
            list.add(head.val);
            head = head.next;
        }

        int res[] = new int[list.size()];
        for(int i=0; i<list.size();i++)
            res[i] = list.get(i);

       return res;
    }

        public TreeNode getBST(int[] nums, int start, int end){
        if(start<= end){  //note <= ...
            int mid = (start + end )/2;
            TreeNode node = new TreeNode(nums[mid]);
            node.left= getBST(nums,start, mid-1);
            node.right = getBST(nums, mid+1, end);
            return node;
        }
        return null;

    }

//**********************************************************************************//
02/21/18
Q19) Add two number 2

/* You are given two non-empty linked lists representing two non-negative
 integers. The most significant digit comes first and each of their nodes
  contain a single digit. Add the two numbers and return it as a linked list.
  You may assume the two numbers do not contain any leading zero,
  except the number 0 itself.
  Follow up:
  What if you cannot modify the input lists? In other words, reversing the
  lists is not allowed.
  Example:
  Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
  Output: 7 -> 8 -> 0 -> 7 */

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        List<Integer> list1 = new ArrayList<>();
        List<Integer> list2 = new ArrayList<>();
        List<Integer> list = new ArrayList<>();

        //idea is to store the values in list, traverse from end,
        //add to new list...reverse the final list, make linked list
        //and return.
        while (l1 != null) {
            list1.add(l1.val);
            l1 = l1.next;
        }
        while (l2 != null) {
            list2.add(l2.val);
            l2 = l2.next;
        }
        List<Integer> maxList, minList;
        if (list1.size() > list2.size()) {
            maxList = list1;
            minList = list2;
        } else {
            maxList = list2;
            minList = list1;
        }

        int carry = 0, minlen = minList.size(), maxlen = maxList.size();
        for (int i = 0; i < maxlen; i++) {
            int sum = minlen > i ? minList.get(minlen - 1 - i) + maxList.get(maxlen - 1 - i) :
                    maxList.get(maxlen - 1 - i);
            sum += carry;
            carry = sum / 10;
            sum = sum % 10;
            list.add(sum);
        }
        if (carry > 0)
            list.add(carry);

        reverse(list);
        ListNode prev = null, cur = null;
        ListNode head = new ListNode(list.get(0));
        prev = head;
        for (int i = 1; i < list.size(); i++) {
            cur = new ListNode(list.get(i));
            prev.next = cur;
            prev = cur;
        }
        return head;
    }

//**********************************************************************************//
02/22/18
Q20) String to integer

/*The function first discards as many whitespace characters as necessary
    until the first non-whitespace character is found. Then, starting from
    this character, takes an optional initial plus or minus sign followed
    by as many numerical digits as possible, and interprets them as a numerical value.
The string can contain additional characters after those that form the
    integral number, which are ignored and have no effect on the
    behavior of this function.
If the first sequence of non-whitespace characters in str is not a valid integral
    number, or if no such sequence exists because either str is empty or it contains
    only whitespace characters, no conversion is performed.
If no valid conversion could be performed, a zero value is returned.
    If the correct value is out of the range of representable values,
    INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.*/

    public static int myAtoi(String str) {
        int ret =0;
        int sign = 1;
        str = str.trim();
        List<Integer> list = new ArrayList<>();

        for(int i=0; i<str.length(); i++){
            char c = str.charAt(i);
            //only + or - can be at the beginning, +-2 is invalid
            if(i ==0 && c == '-') {sign =-1;list.add(0);}
            else if(i==0 && c == '+') {sign =1; list.add(0);}
            //from i=1, numbers should start, else invalid, return 0
            else if(i>0 && list.size()==0 && (c < '0' && c >'9')) return 0;
            else if( c >= '0' && c <='9'){
                list.add( c - '0');
            }
            //eliminate the invalid chars at the end..
            else break;
        }

        long mult = 0;
        for(int i=list.size()-1; i>=0;i--){
            //traverse from the end..multiple with powers of 10..
            long m = (long)Math.pow(10,mult);
            mult++;

            if(ret + (list.get(i) * m) > Integer.MAX_VALUE) {
                if(sign == -1) return Integer.MIN_VALUE;
                else return Integer.MAX_VALUE;
            }
            ret += list.get(i)*m;
        }
        ret *= sign;
        return ret;
    }

//**********************************************************************************//
02/23/18
Q21) Merge K sorted lists
//Merge k sorted linked lists and return it as one sorted list.
// Analyze and describe its complexity.
//I think the complexity is k * n * logk. Because the recursion depth is logK,
// and in each level, every element will be compared. n -no of elements in each list

    public static ListNode mergeKLists(ListNode[] lists) {
        if(lists.length == 0) return null;
        if(lists.length == 1)return lists[0];
        return mergeSort(lists, 0,lists.length-1);
    }

    public static ListNode mergeSort(ListNode[] lists, int start, int end){
    //same like normal merge sort...just add some additional cases
        if(start==end){
            return lists[start];
        }
        else if(start<end){
            int mid = (start+end)/2;
            ListNode l1 =  mergeSort(lists, start, mid);
            ListNode l2 = mergeSort(lists, mid+1,end);
            return merge(l1,l2);
        }
        return null;
    }

    //same..merging two linked lists..
    public static ListNode merge(ListNode l1, ListNode l2){
        ListNode mergedList = new ListNode(0);
        ListNode temp = mergedList;
        while (l1 != null && l2 != null) {
            if (l1.val > l2.val) {
                temp.next = l2;
                l2 = l2.next;
            } else {
                temp.next = l1;
                l1 = l1.next;
            }
            temp = temp.next;
        }

        if (l1 == null) {
            temp.next = l2;
        } else {
            temp.next = l1;
        }
        return mergedList.next;
    }

//**********************************************************************************//
02/23/18
Q22) Trapping Rain water
/*Given n non-negative integers representing an elevation map where the
width of each bar is 1, compute how much water it is able to trap after raining.
  For example,
  Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.*/

    public static int trap(int[] height) {
        if(height.length == 0) return 0;
        int maxSeenSoFar = 0;
        int minSeenLeft = 0;
        int[] maxSeenRight =  new int[height.length];
        int res = 0;

        //calculate the height of water on top of each tower
        // this is possible only  if the height of current tower is less
        // then any one on its left, and any one on its right...

        //for given tower i, maxSeenRight[i] gives the highest tower to its right...
        for(int i=height.length-1; i>=0; i--){
            if(height[i]> maxSeenSoFar){
                maxSeenSoFar = height[i];
            }
            maxSeenRight[i] = maxSeenSoFar;
        }
        //for given tower i, minSeenLeft gives the lowest tower to its left...
        for(int i=0; i<height.length; i++){
            res += Math.max(0, Math.min(minSeenLeft, maxSeenRight[i]) - height[i]);
            if(height[i] > minSeenLeft){
                minSeenLeft = height[i];
            }
        }
        return res;
    }

//**********************************************************************************//
02/23/18
Q23) Least Common Ancestor of Binary Tree
/*
Given a binary tree, find the lowest common ancestor (LCA)
 of two given nodes in the tree.
According to the definition of LCA on Wikipedia:
“The lowest common ancestor is defined between two nodes v
and w as the lowest node in T that has both v and w as descendants
 (where we allow a node to be a descendant of itself).”

         _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
  6      _2       0       8
        /  \
       7   4
For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3.
 Another example is LCA of nodes 5 and 4 is 5, since a node can be
 a descendant of itself according to the LCA definition.
*/

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return null;
        if(root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);

        if(left!=null && right!=null)return root;
        if(left==null && right==null) return null;

        return left==null? right: left;
    }

//**********************************************************************************//
02/24/18
Q24)Least Common Ancestor of Binary Search Tree..

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return root;
        if(root == p || root == q) return root;

        TreeNode left = null, right = null;
        if(p.val < root.val || q.val < root.val)
            left = lowestCommonAncestor(root.left,p,q);

        if(p.val > root.val || q.val > root.val)
            right = lowestCommonAncestor(root.right,p,q);

        if(left!=null && right!=null) return root;
        if(left==null && right==null) return null;

        return left==null? right:left;
}

//**********************************************************************************//
02/24/18
Q25)Minimum height of a binary tree

/*Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest
    path from the root node down to the nearest leaf node.*/

    public int minDepth(TreeNode root) {
        if(root == null) return 0;

        int left = minDepth(root.left);
        int right = minDepth(root.right);
        return 1 + (Math.min(left, right) > 0 ? Math.min(left, right) : Math.max(left, right));
    }


//**********************************************************************************//
02/24/18
Q26)Set Matrix Zeros

    //One solution would be store the indices where rows are 0
    // and columns are 0. it would take int[m], int[n] additional space.
    // this would be O(m+n)

    //better solution would be to use the first row and column
    // of the given matrix to store this values.
    // the value for first row and col can be stored in two flags.
    // so a constant space would be required...   O(1)

        boolean rowZero = false;
        boolean colZero = false;
        int rowLen = matrix.length, colLen = matrix[0].length;

        for(int i=0; i<rowLen; i++){
            if(matrix[i][0] == 0) colZero = true;
        }
        for(int i=0; i<colLen; i++){
            if(matrix[0][i] == 0) rowZero = true;
        }

        //set corresponding enteries in row[o] or col[0]..
        //and track later and make entire row/ column 0's
        for(int i=1; i<rowLen; i++){
            for(int j=1; j<colLen; j++){
                if(matrix[i][j] == 0){
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        //make the entire row/col 0's
        for(int i=1; i<rowLen; i++){
            for(int j=1; j<colLen; j++){
                if(matrix[i][0] == 0 || matrix[0][j] == 0 ){
                    matrix[i][j] = 0;
                }
            }
        }
        //make first row zeros..
        if(rowZero){
            for(int i=0; i<colLen; i++)
                matrix[0][i] = 0;
        }
        //make first col zeros.
        if(colZero){
            for(int i=0; i<rowLen; i++)
                matrix[i][0] = 0;
        }
    }

//**********************************************************************************//
02/25/18
Q27)Valid Graph tree

/*  Given n nodes labeled from 0 to n - 1 and a list of undirected edges
 (each edge is a pair of nodes), write a function to check whether these
  edges make up a valid tree.
    For example:
    Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.
    Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.
    Note: you can assume that no duplicate edges will appear in edges.
    Since all edges are undirected, [0, 1] is the same as [1, 0] and thus
     will not appear together in edges*/


    public boolean validTree(int n, int[][] edges) {
        // initialize adjacency list
        List<List<Integer>> adjList = new ArrayList<List<Integer>>(n);

        // initialize vertices
        for (int i = 0; i < n; i++)
            adjList.add(i, new ArrayList<Integer>());

        // add edges
        for (int i = 0; i < edges.length; i++) {
            int u = edges[i][0], v = edges[i][1];
            adjList.get(u).add(v);
            adjList.get(v).add(u);
        }


        boolean[] visited = new boolean[n];
        Stack<Integer> stack = new Stack<>();

        //dfs
        stack.add(edges[0][0]);
        visited[edges[0][0]] = true;

        while(!stack.isEmpty()){
            int node = stack.peek();
            int notVisitedNode  = getUnvisitedNode(node,adjList,visited);
            if(notVisitedNode != -1){
                stack.push(notVisitedNode);
                visited[notVisitedNode] = true;
            } else {
                stack.pop();
            }
        }
        //check for cycles...if edges = n-1, no cycles
        if(edges.length > n-1)
            return false;

        // make sure all vertices are connected
        for (int i = 0; i < n; i++) {
            if (!visited[i])
                return false;
        }
        return true;
    }

    public int getUnvisitedNode(int node, List<List<Integer>> adjList, boolean[] visited){
        List<Integer> list = adjList.get(node);
        if(list == null) return -1;
        for(Integer n: list)
            if(!visited[n]) return n;

        return -1;
    }

    public static void main(String[] args) {
        ValidGraphTree graph = new ValidGraphTree();
        int grph[][] = new int[][]{
                {1, 0},
                {2,0}};
        System.out.println(graph.validTree(3,grph));
    }

//**********************************************************************************//
02/25/18
Q28)pascal triangle 2

/*  Given an index k, return the kth row of the Pascal's triangle.
    For example, given k = 3,
    Return [1,3,3,1].
    Note:
    Could you optimize your algorithm to use only O(k) extra space?  */

    public List<Integer> getRow(int rowIndex) {
        //when n==0, list will have 1...1st row
        //this base case is taken care of

        //to store the results of each row
        //and keep using and updating the same for subsequent rows
        Integer[] res = new Integer[rowIndex+1];
        Arrays.fill(res,0);
        //1st row
        res[0] = 1;

        // coz index will go till j-1...
        for(int i=1; i<= rowIndex; i++){
            for(int j=i; j>=1; j--){ // traverse from end, not front.
                res[j] += res[j-1];
            }
        }
        return Arrays.asList(res);
    }

//**********************************************************************************//
02/25/18
Q29)Word Ladder

  /*Given two words (beginWord and endWord), and a dictionary's word list,
   find the length of shortest transformation sequence from beginWord to endWord, such that:

    Only one letter can be changed at a time.
    Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
    For example,

    Given:
    beginWord = "hit"
    endWord = "cog"
    wordList = ["hot","dot","dog","lot","log","cog"]
    As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
            return its length 5.

    Note:
    Return 0 if there is no such transformation sequence.
    All words have the same length.
    All words contain only lowercase alphabetic characters.
    You may assume no duplicates in the word list.
    You may assume beginWord and endWord are non-empty and are not the same.  */

    public int ladderLength(String beginWord, String endWord, List<String> wordList) {

        int dist = 1;
        Queue<String> queue = new LinkedList<String>();
        queue.add(beginWord);
        wordList.add(endWord);

        while(!queue.isEmpty()){
            int levelSize = queue.size();
            while(levelSize>0){
                //find adjacent strings from dictionary and
                //add to queue...run bfs..
                String cur = queue.remove();
                List<String> adj = getAdjacentString(cur,wordList);
                if(!adj.isEmpty()){
                    //add all adjacent strings.. and also remove from the dict
                    if(adj.contains(endWord)){
                        return dist+1;
                    }
                    queue.addAll(adj);
                    wordList.removeAll(adj);
                }
                levelSize--;
            }
            dist++; // checking next adjacents...one more branch...so distance increases
        }

        return 0;
    }

    public List<String> getAdjacentString(String cur, List<String> wordList){
        int[] dict = new int[26];
        for(char c: cur.toCharArray())
            dict[c-'a']++;

        List<String> adjacents = new ArrayList<>();

        for(String word: wordList){
            int[] dClone = dict.clone();
            for(char c: word.toCharArray())
                dClone[c-'a']--;

            // one char added, one char removed...for 1 char change..so sum ==0
            if(Arrays.stream(dClone).filter(t -> t==-1).count() == 1){
                adjacents.add(word);
            }
        }
        return adjacents;
    }

//**********************************************************************************//
02/25/18
Q30)Sum root to leaf numbers

/*  Given a binary tree containing digits from 0-9 only,
 each root-to-leaf path could represent a number.
    An example is the root-to-leaf path 1->2->3 which represents
    the number 123.
    Find the total sum of all root-to-leaf numbers.
    For example,
             1
            / \
           2   3
    The root-to-leaf path 1->2 represents the number 12.
    The root-to-leaf path 1->3 represents the number 13.
    Return the sum = 12 + 13 = 25.*/

    public int sumNumbers(TreeNode root) {
        if(root ==null) return  0;
        List<String> list = new ArrayList<>();
        recursiveToLeaf("",root,list);
        int sum = 0;
        for(String str: list){
            sum+= Integer.valueOf(str);
        }
        return sum;
    }

    public void recursiveToLeaf(String cur, TreeNode node, List<String> list){
        //check if leaf node only..then add it
        if(node.left==null && node.right==null){
            //note, we havent added the current node value..so add it
            cur+=node.val;
            list.add(cur);
            return;
        }
        //recursive call only non null nodes...
        if(node.left!=null) recursiveToLeaf(cur+node.val, node.left, list);
        if(node.right!=null) recursiveToLeaf(cur+node.val, node.right, list);
    }